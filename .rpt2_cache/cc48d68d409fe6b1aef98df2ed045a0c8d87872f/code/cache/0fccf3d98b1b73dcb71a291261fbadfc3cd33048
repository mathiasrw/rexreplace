{"code":"var fs = require('fs');\r\nvar path = require('path');\r\nvar globs = require('globs');\r\nimport { outputConfig, step, debug, chat, info, error, die } from './output';\r\nexport var version = 'PACKAGE_VERSION';\r\nexport function engine(config) {\r\n    outputConfig(config);\r\n    step('Displaying steps for:');\r\n    step(config);\r\n    config.pattern = getFinalPattern(config) || '';\r\n    config.replacement = getFinalReplacement(config) || '';\r\n    config.regex = getFinalRegex(config) || '';\r\n    step(config);\r\n    if (handlePipedData(config)) {\r\n        return doReplacement('Piped data', config, config.pipedData);\r\n    }\r\n    config.files = globs.sync(config.files);\r\n    if (!config.files.length) {\r\n        return error(config.files.length + ' files found');\r\n    }\r\n    chat(config.files.length + ' files found');\r\n    step(config);\r\n    config.files\r\n        // Correct filepath\r\n        //.map(filepath=>path.normalize(process.cwd()+'/'+filepath))\r\n        // Find out if any filepaths are invalid\r\n        .filter(function (filepath) { return (fs.existsSync(filepath) ? true : error('File not found:', filepath)); })\r\n        // Do the replacement\r\n        .forEach(function (filepath) { return openFile(filepath, config); });\r\n    function openFile(file, config) {\r\n        if (config.voidAsync) {\r\n            chat('Open sync: ' + file);\r\n            var data = fs.readFileSync(file, config.encoding);\r\n            return doReplacement(file, config, data);\r\n        }\r\n        else {\r\n            chat('Open async: ' + file);\r\n            fs.readFile(file, config.encoding, function (err, data) {\r\n                if (err) {\r\n                    return error(err);\r\n                }\r\n                return doReplacement(file, config, data);\r\n            });\r\n        }\r\n    }\r\n    // postfix argument names to limit the probabillity of user inputted javascript accidently using same values\r\n    function doReplacement(_file_rr, _config_rr, _data_rr) {\r\n        debug('Work on content from: ' + _file_rr);\r\n        // Variables to be accessible from js.\r\n        if (_config_rr.replacementJs) {\r\n            var _pipe_1 = _config_rr.pipedData;\r\n            var _text_1 = _data_rr;\r\n            var _find_1 = _config_rr.pattern;\r\n            var code_rr_1 = _config_rr.replacement;\r\n            var _cwd_1 = process.cwd();\r\n            var _file_1 = '', _path_1 = '', _filename_1 = '', _name_1 = '', _ext_1 = '', dynamicContent_1 = new Function('_fs', '_globs', '_pipe', '_text', '_find', '_file', '_path', '_filename', '_name', '_ext', '_cwd', 'code_rr', 'return eval(code_rr)');\r\n            if (!_config_rr.dataIsPiped) {\r\n                _file_1 = path.normalize(path.join(process.cwd(), _file_rr));\r\n                var pathInfo = path.parse(_file_1);\r\n                _path_1 = pathInfo.dir;\r\n                _filename_1 = pathInfo.base;\r\n                _name_1 = pathInfo.name;\r\n                _ext_1 = pathInfo.ext;\r\n            }\r\n            // Run only once if no captured groups (replacement cant change)\r\n            if (!/\\$\\d/.test(_config_rr.replacement)) {\r\n                _config_rr.replacement = dynamicContent_1(fs, globs, _pipe_1, _text_1, _find_1, _file_1, _path_1, _filename_1, _name_1, _ext_1, _cwd_1, code_rr_1);\r\n            }\r\n            else {\r\n                // Captures groups present, so need to run once per match\r\n                _config_rr.replacement = function () {\r\n                    step(arguments);\r\n                    var __pipe = _pipe_1, __text = _text_1, __find = _find_1, __file = _file_1, __path = _path_1, __filename = _filename_1, __name = _name_1, __ext = _ext_1, __cwd = _cwd_1, __code_rr = code_rr_1;\r\n                    var capturedGroups = '';\r\n                    for (var i = 0; i < arguments.length - 2; i++) {\r\n                        capturedGroups += 'var $' + i + '=' + JSON.stringify(arguments[i]) + '; ';\r\n                    }\r\n                    return dynamicContent_1(fs, globs, __pipe, __text, __find, __file, __path, __filename, __name, __ext, __cwd, capturedGroups + __code_rr);\r\n                };\r\n            }\r\n        }\r\n        // Main regexp of the whole thing\r\n        var result = _data_rr.replace(_config_rr.regex, _config_rr.replacement);\r\n        // The output of matched strings is done from the replacement, so no need to continue\r\n        if (_config_rr.outputMatch) {\r\n            return;\r\n        }\r\n        if (_config_rr.output) {\r\n            debug('Output result from: ' + _file_rr);\r\n            return process.stdout.write(result);\r\n        }\r\n        // Nothing replaced = no need for writing file again\r\n        if (result === _data_rr) {\r\n            chat('Nothing changed in: ' + _file_rr);\r\n            return;\r\n        }\r\n        // Release the memory while storing files\r\n        _data_rr = undefined;\r\n        debug('Write new content to: ' + _file_rr);\r\n        // Write directly to the same file (if the process is killed all new and old data is lost)\r\n        if (_config_rr.voidBackup) {\r\n            return fs.writeFile(_file_rr, result, _config_rr.encoding, function (err) {\r\n                if (err) {\r\n                    return error(err);\r\n                }\r\n                info(_file_rr);\r\n            });\r\n        }\r\n        //Make sure data is always on disk\r\n        var oriFile = path.normalize(path.join(process.cwd(), _file_rr));\r\n        var salt = new Date()\r\n            .toISOString()\r\n            .toString()\r\n            .replace(/:/g, '_')\r\n            .replace('Z', '');\r\n        var backupFile = oriFile + '.' + salt + '.backup';\r\n        if (_config_rr.voidAsync) {\r\n            try {\r\n                fs.renameSync(oriFile, backupFile);\r\n                fs.writeFileSync(oriFile, result, _config_rr.encoding);\r\n                if (!_config_rr.keepBackup) {\r\n                    fs.unlinkSync(backupFile);\r\n                }\r\n            }\r\n            catch (e) {\r\n                return error(e);\r\n            }\r\n            return info(_file_rr);\r\n        }\r\n        // Let me know when fs gets promise'fied\r\n        fs.rename(oriFile, backupFile, function (err) {\r\n            if (err) {\r\n                return error(err);\r\n            }\r\n            fs.writeFile(oriFile, result, _config_rr.encoding, function (err) {\r\n                if (err) {\r\n                    return error(err);\r\n                }\r\n                if (!_config_rr.keepBackup) {\r\n                    fs.unlink(backupFile, function (err) {\r\n                        if (err) {\r\n                            return error(err);\r\n                        }\r\n                        info(_file_rr);\r\n                    });\r\n                }\r\n                else {\r\n                    info(_file_rr);\r\n                }\r\n            });\r\n        });\r\n    }\r\n    function handlePipedData(config) {\r\n        step('Check Piped Data');\r\n        if (config.files.length) {\r\n            if (!config.replacementJs) {\r\n                chat('Piped data never used.');\r\n            }\r\n            return false;\r\n        }\r\n        if (null !== config.pipedData && !config.pipedDataUsed) {\r\n            config.dataIsPiped = true;\r\n            config.output = true;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    function getFinalPattern(config) {\r\n        step('Get final pattern');\r\n        var pattern = config.pattern;\r\n        /*if (config.patternFile) {\r\n            pattern = fs.readFileSync(pattern, 'utf8');\r\n            pattern = new Function('return '+pattern)();\r\n        }*/\r\n        step(pattern);\r\n        return pattern;\r\n    }\r\n    function getFinalReplacement(config) {\r\n        step('Get final replacement');\r\n        /*if(config.replacementFile){\r\n            return oneLinerFromFile(fs.readFileSync(replacement,'utf8'));\r\n        }*/\r\n        if (config.replacementPipe) {\r\n            step('Piping replacement');\r\n            config.pipedDataUsed = true;\r\n            if (null === config.pipedData) {\r\n                return die('No data piped into replacement');\r\n            }\r\n            config.replacement = config.pipedData;\r\n        }\r\n        if (config.outputMatch) {\r\n            step('Output match');\r\n            if ('6' > process.versions.node) {\r\n                return die('outputMatch is only supported in node 6+');\r\n            }\r\n            return function () {\r\n                step(arguments);\r\n                if (arguments.length === 3) {\r\n                    step('Printing full match');\r\n                    process.stdout.write(arguments[0] + '\\n');\r\n                    return '';\r\n                }\r\n                for (var i = 1; i < arguments.length - 2; i++) {\r\n                    process.stdout.write(arguments[i]);\r\n                }\r\n                process.stdout.write('\\n');\r\n                return '';\r\n            };\r\n        }\r\n        // If captured groups then run dynamicly\r\n        if (config.replacementJs && /\\$\\d/.test(config.replacement) && process.versions.node < '6') {\r\n            return die('Captured groups for javascript replacement is only supported in node 6+');\r\n        }\r\n        step(config.replacement);\r\n        return config.replacement;\r\n    }\r\n    /*function oneLinerFromFile(str){\r\n        let lines = str.split(\"\\n\");\r\n        if(lines.length===1){\r\n            return str;\r\n        }\r\n        return lines.map(function (line) {\r\n            return line.trim();\r\n        }).join(' ');\r\n    }*/\r\n    function getFinalRegex(config) {\r\n        step('Get final regex');\r\n        var regex = null;\r\n        var flags = getFlags(config);\r\n        try {\r\n            regex = new RegExp(config.pattern, flags);\r\n        }\r\n        catch (err) {\r\n            die('Wrongly formatted regex pattern', err);\r\n        }\r\n        step(regex);\r\n        return regex;\r\n    }\r\n    function getFlags(config) {\r\n        step('Get flags');\r\n        var flags = '';\r\n        if (!config.voidGlobal) {\r\n            flags += 'g';\r\n        }\r\n        if (!config.voidIgnoreCase) {\r\n            flags += 'i';\r\n        }\r\n        if (!config.voidMultiline) {\r\n            flags += 'm';\r\n        }\r\n        if (config.unicode) {\r\n            flags += 'u';\r\n        }\r\n        step(flags);\r\n        return flags;\r\n    }\r\n}\r\n"}
